#version 450
#define COUNT 2
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
// ---- Structs ----
struct HitRec {
    vec3 point;
    vec3 normal;
    float t;
    bool front_face;
};

struct Ray {
    vec3 orig;
    vec3 dir;
};

struct Sphere {
    vec3 center;
    float radius;
};

// ---- Bind Buffers ----
layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, std140) uniform Globals {
    vec3 camera_origin;
    float aspect_ratio;
    vec2 viewport;
    vec2 window_size;
}
globals;

layout(set = 0, binding = 1, rgba32f) uniform image2D output_image;

layout(set = 0, binding = 2, std140) uniform Spheres {
    Sphere sphere_data[2];
};

// ---- Impl HitRec ----
void set_face_normal(inout HitRec rec, Ray r, vec3 outward_normal) {
    rec.front_face = dot(r.dir, outward_normal) < 0;
    rec.normal = rec.front_face ? outward_normal :-outward_normal;
}

// ---- Impl Ray ----
vec3 ray_at(Ray r, float t) {
    return (r.orig + t*r.dir);
}

// ---- Impl Sphere ----
bool hit_sphere(Sphere s, Ray r, float t_min, float t_max, inout HitRec rec) {
    vec3 oc = r.orig - s.center;
    float a = dot(r.dir, r.dir);
    float half_b = dot(oc, r.dir);
    float c = dot(oc, oc) - s.radius*s.radius;
    float discriminant = half_b*half_b - a*c;

    if (discriminant > 0.0) {
        float root = sqrt(discriminant);
        float temp = (-half_b - root) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.point = ray_at(r, rec.t);
            vec3 outward_normal = (rec.point - s.center) / s.radius;
            set_face_normal(rec, r, outward_normal);
            return true;
        }

        temp = (-half_b + root) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.point = ray_at(r, rec.t);
            vec3 outward_normal = (rec.point - s.center) / s.radius;
            set_face_normal(rec, r, outward_normal);
            return true;
        }
    }
    return false;
}

// ---- Main Body ----
bool hit_list_sphere(Ray r, float t_min, float t_max, inout HitRec rec) {
    HitRec temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for(int i = 0; i < sphere_data.length(); ++i) {
        if (hit_sphere(sphere_data[i], r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }
    return hit_anything;
}

vec3 ray_color(Ray r) {
    HitRec rec;
    if (hit_list_sphere(r, 0, FLT_MAX, rec)) {
        return 0.5 * (rec.normal + vec3(1.0, 1.0, 1.0));
    }

    vec3 unit_direction = normalize(r.dir);
    float t = 0.5*(unit_direction.y + 1.0);
    return ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
}

void main() {
    // Random init stuff
    const float width = globals.window_size.x;
    const float height = globals.window_size.y;
    const float u = float(gl_GlobalInvocationID.x) / float(width - 1.0);
    const float v = float(gl_GlobalInvocationID.y) / float(height - 1.0);

    if (gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height) {
        return;
    }

    // Camera
    const vec3 lookat = vec3(0.0, 0.0, 0.0);
    const vec3 lookfrom = globals.camera_origin;
    const vec3 vup = vec3(0.0, 1.0, 0.0);

    vec3 w = normalize(lookfrom - lookat);
    vec3 uu = normalize(cross(vup, w));
    vec3 vv = cross(w, uu);
    vec3 origin = lookfrom;
    vec3 horizontal = globals.viewport.x * uu;
    vec3 vertical = globals.viewport.y * vv;
    vec3 upper_left_corner = origin - horizontal/2.0 + vertical/2.0 - w;

    // Main loop
    Ray r = Ray(origin, upper_left_corner + u*horizontal - v*vertical - origin);
    vec3 pixel_color = ray_color(r);

    // Output
    const ivec2 pixel_coordinates = ivec2(gl_GlobalInvocationID.xy);
    imageStore(output_image, pixel_coordinates, vec4(pixel_color, 1.0));
}
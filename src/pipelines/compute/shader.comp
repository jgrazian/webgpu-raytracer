#version 450
#define COUNT 2
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
// ---- Structs ----
struct HitRec {
    vec3 point;
    vec3 normal;
    float t;
    bool front_face;
};

struct Ray {
    vec3 orig;
    vec3 dir;
};

struct Sphere {
    vec3 center;
    float radius;
};

// ---- Bind Buffers ----
layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, std140) uniform Globals {
    vec3 camera_origin;
    vec2 viewport;
    vec2 window_size;
    float aspect_ratio;
}
globals;

layout(set = 0, binding = 1, rgba32f) uniform image2D output_image;

// ---- Impl HitRec ----
void set_face_normal(inout HitRec rec, Ray r, vec3 outward_normal) {
    rec.front_face = dot(r.dir, outward_normal) < 0;
    rec.normal = rec.front_face ? outward_normal :-outward_normal;
}

// ---- Impl Ray ----
vec3 ray_at(Ray r, float t) {
    return (r.orig + t*r.dir);
}

// ---- Impl Sphere ----
bool hit_sphere(Sphere s, Ray r, float t_min, float t_max, inout HitRec rec) {
    vec3 oc = r.orig - s.center;
    float a = dot(r.dir, r.dir);
    float half_b = dot(oc, r.dir);
    float c = dot(oc, oc) - s.radius*s.radius;
    float discriminant = half_b*half_b - a*c;

    if (discriminant > 0.0) {
        float root = sqrt(discriminant);
        float temp = (-half_b - root) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.point = ray_at(r, rec.t);
            vec3 outward_normal = (rec.point - s.center) / s.radius;
            set_face_normal(rec, r, outward_normal);
            return true;
        }

        temp = (-half_b + root) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.point = ray_at(r, rec.t);
            vec3 outward_normal = (rec.point - s.center) / s.radius;
            set_face_normal(rec, r, outward_normal);
            return true;
        }
    }
    return false;
}

// ---- Main Body ----
bool hit_list_sphere(Sphere[COUNT] spheres, Ray r, float t_min, float t_max, inout HitRec rec) {
    HitRec temp_rec;
    bool hit_anything = false;
    float closest_so_far = t_max;

    for(int i = 0; i <= COUNT; i++) {
        if (hit_sphere(spheres[i], r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }
    return hit_anything;
}

vec3 ray_color(Ray r, Sphere[COUNT] spheres) {
    HitRec rec;
    if (hit_list_sphere(spheres, r, 0, FLT_MAX, rec)) {
        return 0.5 * (rec.normal + vec3(1.0, 1.0, 1.0));
    }

    vec3 unit_direction = normalize(r.dir);
    float t = 0.5*(unit_direction.y + 1.0);
    return ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
}

void main() {
    // Random init stuff
    const float width = globals.window_size.x;
    const float height = globals.window_size.y;
    const float u = float(gl_GlobalInvocationID.x) / float(width - 1.0);
    const float v = float(gl_GlobalInvocationID.y) / float(height - 1.0);

    if (gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height) {
        return;
    }

    // Camera
    const vec3 origin = vec3(0.0);
    const vec3 horizontal = vec3(globals.viewport.x, 0.0, 0.0);
    const vec3 vertical = vec3(0.0, globals.viewport.y, 0.0);
    const vec3 upper_left_corner = origin - horizontal * 0.5 + vertical * 0.5 - vec3(0, 0, 1.0);

    const Sphere sphere_list[COUNT] = Sphere[COUNT](Sphere(vec3(0, 0, -1), 0.5), Sphere(vec3(0, -100.5, -1), 100));

    // Main loop
    Ray r = Ray(origin, upper_left_corner + u*horizontal - v*vertical - origin);
    vec3 pixel_color = ray_color(r, sphere_list);

    // Output
    const ivec2 pixel_coordinates = ivec2(gl_GlobalInvocationID.xy);
    imageStore(output_image, pixel_coordinates, vec4(pixel_color, 1.0));
}